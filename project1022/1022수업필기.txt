■
오늘의 수업주제
- 패키지와 임포트

■
개발시, 사실상 원본소스와 컴파일 결과물은 반드시 구분해서 관리한다
이때 원본소스는 src, 컴파일 결과물은 bin or classes라는 이름으로 많이 사용한다

이제 src에 .java 소스를 저장하되, 관리목적상 패키지를 직접 만들어야 한다
주의할 것은 원본소스의 패키지는 개발자가 손으로 직접 만들어야 하고,
컴파일 결과물의 패키지는 자동으로 만들어진다

src/animal 이라는 패키지 만들기
Dog.java 라는 클래스를 만들되, 패키지를 선언해야 컴파일시 패키지가 자동으로 만들어진다

이제 이 클래스를 컴파일해서, bin 안에 자동으로 만들어지도록 하자
명령어는 javac -d 경로 Dog.java
c:\workspace\java_workspace\project1022\src\animal 로 이동해서
> javac -d C:\workspace\java_workspace\project1022\bin Dog.java
bin/animal/Dog.java 만들어지면 성공

개발시 일일이 콘솔에서 컴파일하기엔 효율성이 떨어지므로, 툴을 이용해서 이 작업을 진행한다
editplus에서 툴에 등록해야 한다 (참고로 매 프로젝트마다 해야된다)
도구 > 기본설정 > 사용자도구 > 새로운 그룹 선택하고 이름부여(프로젝트 이름과 동일한 이름 부여)
> 어제 한것과 똑같이~ > 도구 : 사용자 도구그룹에서 project1022 만들고
bin/animal을 지우고, 다시 컴파일 해본다 > bin/animal

다른 클래스도 하나 정의해서 서로 다른 경로에 있는 클래스를 사용하는 법을 배워보자


package use;
원래는 C:\workspace\java_workspace\project1022\bin\use 이다
use 앞에 bin까지를 환경변수로 등록하면 된다
기존에 이미 환경변수 classpath 에 등록된 경로가 있을때는 지우지 말고 세미콜론으로 연결하면 된다
경로;경로2;경로3... 이런식 (세미콜론 뒤에 절대로 띄어쓰기 있으면 안된다)
일반적으로 환경변수가 등록되고 나면, 윈도우 OS가 모든 프로그램을 대상으로 broadCasting을 한다(바뀐내용을 방송하는 행위)
따라서, 바뀌기 전에 열어놓았던 모든 프로그램을 종료했다가 다시 열어야 한다
UseDog 다시 컴파일해보기
또 에러가난다. 나와는 다른 경로에 있는 클래스는 반드시 import문도 함께 작성해야 한다
클래스 package 선언부 아래에 사용하고 싶은 클래스의 경로를 명시한다
import bin 이하의 경로를 명시한다
사용하고싶은 클래스의 package 선언과 일치한다

이제 컴파일
또 에러가 나는데 이것은 정상적으로 인식한 에러이다
단지, 패키지에 들어간 클래스는 반드시 외부에서 접근할 수 있도록 접근제한을 풀어줘야 하는데 그걸 안했다
지금부터 Dog 클래스를 외부에서 사용할 수 있도록 접근제한을 푼다


1) 컴파일시 원하는 경로에 클래스 생성하는법
2) 다른 경로에 있는 클래스 사용하는법 (import, classpath 이용)
-----------------------------------------------------------------------------------------------------------------
■
패키지 사용시 클래스 실행하는 법

[명령어 원칙]
패키지사용 안할때) java 클래스명
패키지사용 할때) java 패키지경로.클래스명

cmd창에서 명령어 먼저 실습해보고 editplus에 등록
> java use.UseDog
아무데서나 UseDog 클래스를 사용할 수 있다
이유는 환경변수에 classpath를 등록했기 때문
그런데 로직이 없어서 아무 반응이 없다
로직 추가하고 잘되는지 확인

이제 실행 명령어도 editplus 툴에 등록해서 편하게 개발한다
$(Prompt).$(FileNameNoExt) 
실행 ctrl+2
프롬프트에서 물어본다 
실행할 UseDog클래스가 소속된 패키지명이 뭐냐고
use 이므로 use라고 치고 엔터친다 > 잘된다


■
실습
1) 새로운 프로젝트 디렉토리를 만든 후 그 안에 원본소스 src, 컴파일 결과물 bin 디렉토리를 둔다

2) src의 원본소스를 컴파일하면 bin으로 자동으로 들어갈 수 있도록 eidtplus에 도구를 등록한다
	1. editplus에 C:\workspace\java_workspace\packagetest\bin 등록
	2. 이 경로를 환경변수에 등록하기
	    이 경로가 이 프로젝트의 루트 클래스패스가 된다
	    classpath에 C:\workspace\java_workspace\packagetest\bin 추가
	    제일 위로 올라오게 해주면, 클래스명이 중복될 경우에 우선순위를 갖게 된다(필수는 아님)
	3. 환경변수가 바뀌면, 관련된 프로그램도 종료 후 다시 켜야한다 (cmd, editplus)

3) src에 Cat이라는 클래스를 pet이라는 패키지에 두고 eat() 메서드 추가한 후 컴파일 한다

4) src에 UseCat이라는 클래스를 study 라는 패키지에 두고 main() 메서드에서
     	고양이의 eat() 메서드를 호출하는 코드를 작성하고 컴파일한다

5) editplus 도구에 실행명령어를 등록하고 ctrl+2
	java 패키지명.클래스명	을 editplus에 등록
	인수 : 패키지명 묻는 인수창.확장자를 뺀 파일이름

- 이렇게 공부하지 않으면 나중에 개발자로 취업했을때 이클립스 없으면 개발을 못한다
실제 현장에 나가서, 리눅스나 특정 os에 개발툴 없이 컴파일 해야할 경우가 많은데,
이클립스는 서버에 설치되어 있지 않다.. 그래서 이 개념이 필요하다
원래 서버는 그냥 서버로서 수행만 하지 개발용이 아니라서, (서버는 까만화면에 흰글씨만 나오는 콘솔화면)
꼭 연습해야한다!!!


■ 접근제한자

접근 제한자 
: 클래스내에 작성되는 변수는 지금까지는 색상, 가격 이런 기본적인 연습용 데이터였지만
  사실상 자바 개발자가 현업에서 다루는 업무는 주로 계좌, 고객정보 등 상당히 민감한 데이터를 다룬다
  따라서 클래스 내에 있는 변수는 데이터이므로 보호받아야 한다
  자바에서는 이렇게 데이터를 보호할 수 있는 보안 장치를 지원해 주는데, 이를 가리켜 접근 제한자라 한다


접근제한자의 종류 
  약한 것 순으로 나열하자면

  public (보안도 아님 그냥 공개임)
  protected (상속관계에 있는 부모자식 클래스끼리만 접근 가능)
  default (같은 패키지 안에 있는 클래스끼리만 접근 가능, 상속받았다 할지라도 같은 패키지가 아니라면 접근 못함)
  private (같은 클래스내의 멤버끼리만 접근 가능)
	ex. 멤머메서드가 멤버변수에 접근
  결국 보안 순서는 public < protected < default < private
  마치 개발할때 개발자가 보안을 철저히 따져가면서 클래스를 만들 것 같지만 사실 private을 많이 이용한다

실습 : Account, UseAccount

■■■■■■■■■UseAccount 'public class' 맞는지 확인!



■
돼지가 만두를 4개 갖고 있다
public 은 모든 사람이 다 먹는다. 돼지도 제한을 못한다
protected 는 돼지의 자녀까지만 먹는다. 자녀가 아니면 못먹는다. 단, 자녀가 아니더라도 같은 집에 세들어 사는 사람은 먹는다
default는 자녀고 뭐고 안봐주고 그냥 세입자만 먹는다
private은 돼지 혼자만 먹는다

그럼 private으로 선언된 만두에 손을 대려면?
- 오직 돼지밖에 손댈 수 없기 때문에 돼지를 이용해야 한다... 즉 간접적으로만 접근할 수 있다

그럼 만두가 필드, 생성자, 메서드 모두를 포함한 하나의 형태라고 보나?
- 만두를 클래스 안의 변수라고 본다. 모두 같은 클래스에 있다고 본다

private으로 선언된 변수는 절대 아무도 외부에서 접근할 수 없으므로 변수에 접근하려면 메서드를 이용해야 한다
이 원리를 일상생활에서 찾아보면 리모콘 
케이스가 달려서 나오는 이유?
1) 내장부품은 소중하기 때문에 노출되면 망가진다
2) 일반인들은 데이터 내부적인 지식이 없기 때문에, 손쉽게 조종하기 위해서는 껍데기를 감싸서 조작방법만 익히면 된다. 즉 버튼만 누르면 된다
    조작방법은 곧 방법이 영어로 메서드니까 결국 메서드를 통해 물건을 제어하면 된다
결론) 우리가 작성한 클래스에서 메서드없이 변수를 public으로 노출시키는 행위는 리모콘에 껍데기가 없는 것과 같다!!!
       그래서 소중하다고 생각되는 변수는 외부에서 직접 접근할 수 없게 무조건 private으로 막고, 
       이 변수에 대해 간접적으로 접근할 수 있는 방법은 메서드를 통해 제공한다
       이걸 보고 '은닉화', 영어로는 '캡슐화' 라고 한다.. 아주아주 많이 쓴다


[정리]
접근제한자는 자바에서 보안을 처리하기 위한 방법을 제공한다
여기서 특히 private의 활용도가 상당히 높다
사실상 클래스내에 선언되는 변수는 모두 private 하는게 많다. 데이터는 보호해야 하므로...
리모콘처럼 내부장치는 덮어놓아야 한다
이 내부장치를 외부에서 접근하려면 접근 "방법"을 제공해줘야 하는데 그게 바로 gettet/setter 메서드이다
그리고 데이터를 private 보호하고, 오직 getter/setter를 통해서 데이터를 간접 제어할 수 있도록 
클래스를 정의하는 기법을 가리켜 객체지향 OOP에서는 은닉화(=EnCapsulation)캡슐화라고 한다

질문) setter/getter를 어차피 제공하면 private으로 막아놓았던 변수에 결국 외부의 주체가 접근하게 되는건데 의미가 있나?

아래의 변수는 아무도 직접 접근못하게 일부러 보안을 강화했다
private int balance = 100000;
그런데 막상 setter/getter를 이용해서 외부의 침입자가 제어할 수 있다면 하나 마나인것 아닌가?
제한을 가한다...

누군가 계좌의 잔고를 0으로 바꾸려고 하는 악의를 가진 객체가 있다고 하자
acc.setBalance(0);

근데 메서드에서 뭔가 제한을 가하면 되지 않을까?
public void setBalance(int balance){
	//만일 나쁜놈이 이상한 짓을 하면 조건을 주면된다
	if(balance > 0){	//이런식으로.. (마치 리모콘에서 이용자가 쓸데없는 짓을 하면 기능에 제한을 가하듯)
		this.balance=balance;
	}
}
결론은 메서드를 통해 얼마든지 방어할 수 있다는 것!!!


은닉화에 작성되는 메서드 정의표기법은 규칙이 정해져 있다
ex) private String name;
      private String price;

getter와 setter 작성시 합성어는 뒷단어의 첫 철자를 대문자로 해야 한다는 규칙이 있다

풀이)
public void setName(String name){
	this.name=name;
}
public String getName(){	//get 다음에 N대문자, 그리고 getter는 반환값이 있다
	return name;
}
public void setPrice(String price){
	this.price=price;
}
public String getPrice(){
	return price;
}



■
객체지향 언어인 자바에서는 모든 사물은 단독으로 존재할 수 없다는 관점을 2가지 경우로 나누어 생각한다
(is a, has a 개념은 ocjp 시험에 나온다)
1) is a 관계
	ex) Duck is a Bird "오리는 새다"
	      상속관계를 나타내는 말이다

2) has a 관계
	ex) Car has a Wheel "자동차는 바퀴를 가지고 있다"
	      부품관계를 나타내는 말이다
	      부품관계란, 특정객체가 다른객체를 멤버변수로 보유한 경우를 말한다
	
is a 공부해보기
구글드라이브문제 - java - 10.클래스간 관계 4번문제
현실의 자동차, 택시, 버스, 트럭을 자바 언어로 반영하되 재사용성을 고려해서 설계해 보세요
상속을 이용해서 자동차 - 택시, 버스, 트럭을 만들어보자 > editplus car 패키지





